#!/usr/bin/env bash
set -euo pipefail

# Name: global-replace
# Category: text
# Description: Safe project-wide search & replace with ripgrep + sd (dry-run by default).
# Usage:
#   global-replace <pattern> <replacement> [path...]
#   global-replace --apply <pattern> <replacement> [path...]
#   global-replace --literal <pattern> <replacement> [path...]
#
# Notes:
#   - Dry-run by default: shows files + total matches, no edits.
#   - Use --apply to perform replacements.
#   - --literal treats pattern as plain string (no regex).

if ! command -v rg >/dev/null 2>&1; then
  printf 'Error: global-replace requires ripgrep (rg). Install via: brew install ripgrep\n' >&2
  exit 1
fi

if ! command -v sd >/dev/null 2>&1; then
  printf 'Error: global-replace requires sd. Install via: brew install sd\n' >&2
  exit 1
fi

APPLY=false
LITERAL=false

args=()
while [ "$#" -gt 0 ]; do
  case "$1" in
    --apply)
      APPLY=true
      shift
      ;;
    --literal)
      LITERAL=true
      shift
      ;;
    -h|--help)
      sed -n '4,40p' "$0"
      exit 0
      ;;
    -*)
      printf 'Error: unknown option: %s\n' "$1" >&2
      exit 1
      ;;
    *)
      args+=("$1")
      shift
      ;;
  esac
done

if [ "${#args[@]}" -lt 2 ]; then
  printf 'Usage: global-replace [--apply] [--literal] <pattern> <replacement> [path...]\n' >&2
  exit 1
fi

pattern="${args[0]}"
replacement="${args[1]}"
paths=("${args[@]:2}")

if [ "${#paths[@]}" -eq 0 ]; then
  paths=(.)
fi

rg_flags=(--hidden --glob '!.git' --no-heading)
sd_flags=()

if [ "$LITERAL" = true ]; then
  rg_flags+=(-F)
  sd_flags+=(-s)  # string-literal mode in sd
fi

# Collect match counts per file
matches_output="$(
  rg "${rg_flags[@]}" --count-matches -- "$pattern" "${paths[@]}" 2>/dev/null || true
)"

if [ -z "$matches_output" ]; then
  printf 'global-replace: No matches for "%s" under %s\n' "$pattern" "${paths[*]}"
  exit 0
fi

# Compute files list and total matches
mapfile -t files < <(printf '%s\n' "$matches_output" | awk -F: '{print $1}' | sort -u)
file_count="${#files[@]}"
total_matches="$(printf '%s\n' "$matches_output" | awk -F: '{s+=$2} END {print (s==""?0:s)}')"

printf 'global-replace: "%s" -> "%s"\n' "$pattern" "$replacement"
printf '  Paths:         %s\n' "${paths[*]}"
printf '  Files touched: %d\n' "$file_count"
printf '  Total matches: %s\n\n' "$total_matches"

printf 'Sample matches (first 20 lines):\n\n'
printf '%s\n' "$(
  rg "${rg_flags[@]}" --line-number --color=always -- "$pattern" "${paths[@]}" 2>/dev/null \
    | head -n 20
)"

if [ "$APPLY" = false ]; then
  printf '\nDry-run only. To apply replacements, re-run with --apply.\n'
  exit 0
fi

printf '\nAbout to apply replacements in %d file(s), %s match(es).\n' "$file_count" "$total_matches"
printf 'Proceed? [y/N]: '
read -r reply
case "$reply" in
  y|Y|yes|YES) ;;
  *) printf 'Aborted; no changes made.\n'; exit 0 ;;
esac

for f in "${files[@]}"; do
  [ -f "$f" ] || continue
  printf 'Updating %s\n' "$f"
  sd "${sd_flags[@]}" -- "$pattern" "$replacement" "$f"
done

printf 'global-replace: done.\n'
