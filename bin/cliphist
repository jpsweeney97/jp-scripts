#!/usr/bin/env bash
set -euo pipefail

# Name: cliphist
# Category: notes
# Description: Simple clipboard history: save, browse, and restore clipboard entries.
# Usage:
#   cliphist save        # save current clipboard contents
#   cliphist             # browse history with fzf, restore selected to clipboard
#   cliphist clear       # delete all saved entries (with confirmation)
#
# Env:
#   CLIPHIST_DIR   Directory for history files (default: $HOME/.local/share/jp-cliphist)

HIST_DIR="${CLIPHIST_DIR:-"$HOME/.local/share/jp-cliphist"}"
mkdir -p "$HIST_DIR"

usage() {
  cat <<'EOF'
Usage:
  cliphist save        # save current clipboard contents
  cliphist             # browse history with fzf, restore selected to clipboard
  cliphist clear       # delete all saved entries (with confirmation)
EOF
}

if ! command -v pbpaste >/dev/null 2>&1 || ! command -v pbcopy >/dev/null 2>&1; then
  printf 'Error: cliphist requires pbpaste/pbcopy (macOS clipboard tools).\n' >&2
  exit 1
fi

cmd="${1-}"

save_clipboard() {
  local tmp file last

  tmp="$(mktemp "${TMPDIR:-/tmp}/cliphist.XXXXXX")"
  pbpaste >"$tmp"

  if [ ! -s "$tmp" ]; then
    printf 'Clipboard is empty; nothing to save.\n'
    rm -f "$tmp"
    return
  fi

  # Use timestamp-based filename; replace ":" so it's filesystem-safe.
  file="$(date -Iseconds | tr ':' '-' ).txt"
  file="$HIST_DIR/$file"

  # Optional: avoid saving if identical to most recent entry.
  last="$(ls -1t "$HIST_DIR" 2>/dev/null | head -n 1 || true)"
  if [ -n "$last" ] && cmp -s "$tmp" "$HIST_DIR/$last"; then
    printf 'Clipboard unchanged from last saved entry; not saving duplicate.\n'
    rm -f "$tmp"
    return
  fi

  mv "$tmp" "$file"
  printf 'Saved clipboard to %s\n' "$file"
}

browse_and_restore() {
  if ! command -v fzf >/dev/null 2>&1; then
    printf 'Error: cliphist interactive mode requires fzf.\n' >&2
    exit 1
  fi

  if ! command -v bat >/dev/null 2>&1; then
    printf 'Error: cliphist interactive mode requires bat.\n' >&2
    exit 1
  fi

  # List files newest first
  mapfile -t files < <(ls -1t "$HIST_DIR" 2>/dev/null || true)
  if [ "${#files[@]}" -eq 0 ]; then
    printf 'No clipboard history entries found. Use "cliphist save" first.\n'
    exit 0
  fi

  # Build menu: TIMESTAMP | first line
  menu=""
  for f in "${files[@]}"; do
    first_line="$(head -n 1 "$HIST_DIR/$f" | tr '\t' ' ' | cut -c1-80)"
    ts="${f%.txt}"
    menu+="$ts | $first_line"$'\n'
  done

  selection="$(
    printf '%s' "$menu" \
      | fzf --with-nth=1,2 \
            --header='Select clipboard entry to restore (ENTER), ESC to cancel.' \
            --prompt='cliphist> ' \
            --preview 'ts=$(printf "%s" {} | cut -d"|" -f1 | sed "s/ *$//"); \
                       file=$(printf "%s.txt" "$ts"); \
                       bat --style=plain --color=always --line-range=1:200 "'"$HIST_DIR"'/$file" 2>/dev/null'
  )" || exit 0

  ts_sel="$(printf '%s' "$selection" | cut -d'|' -f1 | sed 's/ *$//')"
  [ -z "$ts_sel" ] && { printf 'No selection.\n'; exit 0; }

  file="$HIST_DIR/$ts_sel.txt"
  if [ ! -f "$file" ]; then
    printf 'Selected file missing: %s\n' "$file" >&2
    exit 1
  fi

  pbcopy <"$file"
  printf 'Restored clipboard from %s\n' "$file"
}

clear_history() {
  mapfile -t files < <(ls -1 "$HIST_DIR" 2>/dev/null || true)
  if [ "${#files[@]}" -eq 0 ]; then
    printf 'No history files to delete.\n'
    return
  fi

  printf 'This will delete %d clipboard history entries in %s\n' "${#files[@]}" "$HIST_DIR"
  printf 'Proceed? [y/N]: '
  read -r reply
  case "$reply" in
    y|Y|yes|YES)
      rm -f "$HIST_DIR"/*
      printf 'Clipboard history cleared.\n'
      ;;
    *)
      printf 'Aborted.\n'
      ;;
  esac
}

case "$cmd" in
  save)
    save_clipboard
    ;;
  clear)
    clear_history
    ;;
  "" )
    browse_and_restore
    ;;
  * )
    usage >&2
    exit 1
    ;;
esac
