#!/usr/bin/env bash
set -euo pipefail

# Name: jpcom
# Category: meta
# Description: List all custom JP commands and what they do.
# Usage:
#   jpcom                       # list all commands
#   jpcom grep <pattern>        # search names/descriptions/categories
#   jpcom cat <category>        # list only commands in a given category
#   jpcom info <name>           # show details for a single command
#   jpcom cats                  # list available categories
#   jpcom fzf                   # fuzzy-pick a command and print its name

# Resolve repo root relative to this script (bin/ -> repo root)

usage() {
  sed -n '4,40p' "$0" | sed 's/^# \?//'
}

case "${1-}" in
  -h|--help)
    usage
    exit 0
    ;;
esac

SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]:-$0}")" && pwd)"
REPO_ROOT="$(cd -- "$SCRIPT_DIR/.." && pwd)"
REGISTRY_PATH="$REPO_ROOT/registry/commands.json"
# shellcheck source=../lib/fzf.sh disable=SC1091
. "$REPO_ROOT/lib/fzf.sh"

if ! command -v jq >/dev/null 2>&1; then
  printf 'Error: jq is required for jpcom. Install with: brew install jq\n' >&2
  exit 1
fi

if [ ! -f "$REGISTRY_PATH" ]; then
  printf 'Error: registry not found at %s\n' "$REGISTRY_PATH" >&2
  exit 1
fi

print_all() {
  jq -r '
    .commands
    | sort_by(.category, .name)
    | (["Command","Category","Description"] | @tsv),
      (map([.name, .category, .description] | @tsv)[])
  ' "$REGISTRY_PATH" | column -t -s $'\t'
}

grep_commands() {
  local pattern="$1"
  jq -r '
    .commands
    | map(select(
        (.name | test($p; "i")) or
        (.description | test($p; "i")) or
        (.category | test($p; "i"))
      ))
    | sort_by(.category, .name)
    | (["Command","Category","Description"] | @tsv),
      (map([.name, .category, .description] | @tsv)[])
  ' --arg p "$pattern" "$REGISTRY_PATH" | column -t -s $'\t'
}

cat_filter() {
  local cat="$1"
  jq -r '
    .commands
    | map(select(.category == $c))
    | sort_by(.name)
    | (["Command","Category","Description"] | @tsv),
      (map([.name, .category, .description] | @tsv)[])
  ' --arg c "$cat" "$REGISTRY_PATH" | column -t -s $'\t'
}

list_categories() {
  jq -r '
    .commands
    | group_by(.category)
    | map({category: .[0].category, count: length})
    | sort_by(.category)
    | (["Category","Count"] | @tsv),
      (map([.category, (.count|tostring)] | @tsv)[])
  ' "$REGISTRY_PATH" | column -t -s $'\t'
}

show_info() {
  local name="$1"
  local result
  result="$(jq -r '
    .commands
    | map(select(.name == $n))
    | if length == 0 then
        "NOT_FOUND"
      else
        .[0] as $cmd
        | [
            "Name:        \($cmd.name)",
            "Path:        \($cmd.path)",
            "Category:    \($cmd.category)",
            "Description: \($cmd.description)",
            (if (($cmd.tags // []) | length > 0) then "Tags:        " + ($cmd.tags | join(", ")) else empty end),
            (if (($cmd.requires // []) | length > 0) then "Requires:    " + ($cmd.requires | join(", ")) else empty end),
            (if (($cmd.examples // []) | length > 0)
               then "Examples:\n" + ($cmd.examples | map("  - " + .) | join("\n"))
               else empty end)
          ]
          | join("\n")
      end
  ' --arg n "$name" "$REGISTRY_PATH")"

  if [ "$result" = "NOT_FOUND" ]; then
    printf 'Error: no command named %s in registry.\n' "$name" >&2
    exit 1
  fi

  printf '%s\n' "$result"
}

fzf_select() {
  if ! fzf_require; then
    exit 1
  fi

  fzf_set_common_opts "jpcom> " "Select a command (prints name to stdout)"

  local selection
  selection="$(
    jq -r '
      .commands
      | sort_by(.category, .name)
      | map([.name, .category, .description] | @tsv)
      | .[]
    ' "$REGISTRY_PATH" \
    | fzf --with-nth=1,2,3 \
          --delimiter=$'\t' \
          "${FZF_COMMON_OPTS[@]}" \
      || true
  )"

  if [ -z "$selection" ]; then
    return 1
  fi

  # Extract the first field (command name) before the first tab
  printf '%s\n' "${selection%%$'\t'*}"
}

print_usage() {
  printf 'Usage:\n' >&2
  printf '  jpcom                       # list all commands\n' >&2
  printf '  jpcom grep <pattern>        # search names/descriptions/categories\n' >&2
  printf '  jpcom cat <category>        # filter by category\n' >&2
  printf '  jpcom info <name>           # show details for a single command\n' >&2
  printf '  jpcom cats                  # list available categories\n' >&2
  printf '  jpcom fzf                   # fuzzy-pick a command and print its name\n' >&2
}

case "${1-}" in
  "" )
    print_all
    ;;
  grep )
    if [ "${2-}" = "" ]; then
      printf 'Usage: jpcom grep <pattern>\n' >&2
      exit 1
    fi
    grep_commands "$2"
    ;;
  cat )
    if [ "${2-}" = "" ]; then
      printf 'Usage: jpcom cat <category>\n' >&2
      exit 1
    fi
    cat_filter "$2"
    ;;
  info )
    if [ "${2-}" = "" ]; then
      printf 'Usage: jpcom info <name>\n' >&2
      exit 1
    fi
    show_info "$2"
    ;;
  cats )
    list_categories
    ;;
  fzf )
    fzf_select
    ;;
  -h|--help )
    print_usage
    ;;
  * )
    print_usage
    exit 1
    ;;
esac
