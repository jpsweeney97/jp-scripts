#!/usr/bin/env bash
set -euo pipefail

# Name: gclean-branches
# Category: git
# Description: List (and optionally delete) local branches merged into the default base.
# Usage:
#   gclean-branches               # list merged branches (dry-run)
#   gclean-branches --delete      # delete merged branches safely (git branch -d)
#   gclean-branches --force       # delete merged branches forcefully (git branch -D)
#   gclean-branches --base BRANCH # override base branch (default tries origin/HEAD, main, master)
#
# Notes:
# - Only affects local branches.
# - Never deletes the base branch or current branch.
# - Always shows what it will do before deleting.

usage() {
  sed -n '4,40p' "$0" | sed 's/^# \?//'
}

case "${1-}" in
  -h|--help)
    usage
    exit 0
    ;;
esac

SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]:-$0}")" && pwd)"
REPO_ROOT="$(cd -- "$SCRIPT_DIR/.." && pwd)"
# shellcheck source=../lib/git.sh disable=SC1091
. "$REPO_ROOT/lib/git.sh"

if ! git_require_repo; then
  exit 1
fi

MODE="list"
BASE_OVERRIDE=""

while [ "$#" -gt 0 ]; do
  case "$1" in
    --delete)
      MODE="delete"
      shift
      ;;
    --force)
      MODE="force"
      shift
      ;;
    --base)
      if [ "${2-}" = "" ]; then
        printf 'Error: --base requires a branch name.\n' >&2
        exit 1
      fi
      BASE_OVERRIDE="$2"
      shift 2
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    -*)
      printf 'Error: unknown option: %s\n' "$1" >&2
      usage >&2
      exit 1
      ;;
    *)
      printf 'Error: unexpected argument: %s\n' "$1" >&2
      usage >&2
      exit 1
      ;;
  esac
done

# Determine base branch
if [ -n "$BASE_OVERRIDE" ]; then
  BASE="$BASE_OVERRIDE"
else
  # Try origin/HEAD, then main, then master
  BASE=""
  origin_head="$(git symbolic-ref --quiet --short refs/remotes/origin/HEAD 2>/dev/null || true)"
  if [ -n "$origin_head" ]; then
    BASE="${origin_head#origin/}"
  elif git show-ref --verify --quiet refs/heads/main; then
    BASE="main"
  elif git show-ref --verify --quiet refs/heads/master; then
    BASE="master"
  fi
fi

if [ -z "$BASE" ]; then
  printf 'Error: could not determine base branch. Use --base BRANCH.\n' >&2
  exit 1
fi

if ! git show-ref --verify --quiet "refs/heads/$BASE"; then
  printf 'Error: base branch "%s" does not exist locally.\n' "$BASE" >&2
  exit 1
fi

CURRENT_BRANCH="$(git_current_branch)"

printf 'Base branch: %s\n' "$BASE"
printf 'Current branch: %s\n' "$CURRENT_BRANCH"

MERGED_BRANCHES="$(git branch --format='%(refname:short)' --merged "$BASE" || true)"

CANDIDATES=""
while IFS= read -r br; do
  [ -z "$br" ] && continue
  # Skip base and current
  if [ "$br" = "$BASE" ] || [ "$br" = "$CURRENT_BRANCH" ]; then
    continue
  fi
  CANDIDATES="${CANDIDATES}${br}\n"
done <<EOF
$MERGED_BRANCHES
EOF

if [ -z "$CANDIDATES" ]; then
  printf 'No merged local branches to clean.\n'
  exit 0
fi

printf '\nMerged local branches (eligible for cleanup):\n'
printf '%s' "$CANDIDATES"

case "$MODE" in
  list)
    printf '\nDry-run only. Re-run with --delete or --force to actually delete branches.\n'
    ;;
  delete)
    printf '\nDeleting merged branches with "git branch -d":\n'
    printf '%s' "$CANDIDATES" | while IFS= read -r br; do
      [ -z "$br" ] && continue
      printf '  git branch -d %s\n' "$br"
      git branch -d "$br"
    done
    ;;
  force)
    printf '\nForce-deleting merged branches with "git branch -D":\n'
    printf '%s' "$CANDIDATES" | while IFS= read -r br; do
      [ -z "$br" ] && continue
      printf '  git branch -D %s\n' "$br"
      git branch -D "$br"
    done
    ;;
esac
