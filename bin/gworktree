#!/usr/bin/env bash
set -euo pipefail

# Name: gworktree
# Category: git
# Description: Manage git worktrees with safe defaults and fzf picker.
# Usage:
#   gworktree list                   # list worktrees (path + branch)
#   gworktree add <branch> [--from base] [--force]  # create worktree (creates branch if missing)
#   gworktree fzf [--code]           # fzf picker; prints path or opens code
#   gworktree prune                  # prune stale worktrees via git worktree prune

usage() {
  sed -n '4,120p' "$0" | sed 's/^# \?//'
}

SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]:-$0}")" && pwd)"
REPO_ROOT="$(cd -- "$SCRIPT_DIR/.." && pwd)"
# shellcheck source=../lib/log.sh disable=SC1091
. "$REPO_ROOT/lib/log.sh"
# shellcheck source=../lib/deps.sh disable=SC1091
. "$REPO_ROOT/lib/deps.sh"
# shellcheck source=../lib/fzf.sh disable=SC1091
. "$REPO_ROOT/lib/fzf.sh"
# shellcheck source=../lib/git.sh disable=SC1091
. "$REPO_ROOT/lib/git.sh"
# shellcheck source=../lib/config.sh disable=SC1091
. "$REPO_ROOT/lib/config.sh"

cmd="${1-}"
[ -n "$cmd" ] || cmd="fzf"
[ "$cmd" != "--help" ] || cmd="-h"

if [ "$cmd" = "-h" ] || [ "$cmd" = "--help" ]; then
  usage
  exit 0
fi

deps_require git git || exit 1
deps_warn_missing code "" "VS Code integration" || true
git_require_repo || exit 1

get_worktree_root() {
  local default_root
  default_root="$(git_repo_root)/.worktrees"
  jp_config_get worktree_root "$default_root" JP_WORKTREE_ROOT
}

ensure_worktree_root() {
  local root="$1"
  mkdir -p "$root"
}

list_worktrees() {
  local root="$1"
  local output
  output="$(git_worktree_list)" || return 1

  printf '%s\n' "$output" \
    | while IFS=$'\t' read -r path branch; do
        [ -z "$path" ] && continue
        status="clean"
        if git_worktree_is_dirty "$path"; then
          status="dirty"
        fi
        rel="${path#"$root"/}"
        printf '%s\t%s\t%s\n' "$branch" "$status" "$rel"
      done
}

case "$cmd" in
  list)
    root="$(get_worktree_root)"
    list_worktrees "$root"
    ;;

  add)
    [ "$#" -ge 2 ] || log_fatal "gworktree add <branch> [--from base] [--force]"
    shift
    branch="$1"
    shift
    base="origin/main"
    force=0

    while [ "$#" -gt 0 ]; do
      case "$1" in
        --from)
          base="${2-}"
          [ -n "$base" ] || log_fatal "--from requires a base branch"
          shift 2
          ;;
        --force)
          force=1
          shift
          ;;
        *)
          log_fatal "Unknown option for add: $1"
          ;;
      esac
    done

    if git_is_dirty && [ "$force" -ne 1 ]; then
      log_fatal "Repo has uncommitted changes. Use --force to proceed."
    fi

    root="$(get_worktree_root)"
    ensure_worktree_root "$root"
    dest="$root/$branch"

    if [ -d "$dest" ]; then
      log_fatal "Destination already exists: $dest"
    fi

    if git_branch_exists "$branch"; then
      log_info "Branch exists; adding worktree for $branch"
    else
      log_info "Creating branch $branch from $base"
      git branch "$branch" "$base"
    fi

    log_run git worktree add "$dest" "$branch"
    log_info "Created worktree at $dest"
    printf '%s\n' "$dest"
    ;;

  prune)
    log_run git worktree prune
    ;;

  fzf)
    shift || true
    open_code=0
    while [ "$#" -gt 0 ]; do
      case "$1" in
        --code)
          open_code=1
          shift
          ;;
        *)
          log_fatal "Unknown option for fzf: $1"
          ;;
      esac
    done

    deps_require fzf fzf || exit 1
    deps_warn_missing bat bat "preview highlighting" || true

    root="$(get_worktree_root)"
    ensure_worktree_root "$root"

    items="$(git_worktree_list)"
    if [ -z "$items" ]; then
      log_warn "No worktrees."
      exit 0
    fi

    selection_source="$(
      printf '%s\n' "$items" \
        | while IFS=$'\t' read -r path branch; do
            [ -z "$path" ] && continue
            status="clean"
            if git_worktree_is_dirty "$path"; then
              status="dirty"
            fi
            printf '%s\t%s\t%s\n' "$branch" "$status" "$path"
          done
    )"

    if [ "${GWORKTREE_NONINTERACTIVE:-0}" -eq 1 ]; then
      selection="$(printf '%s\n' "$selection_source" | awk -F '\t' 'index($3, "/.worktrees/") > 0 { print; exit }')"
      if [ -z "$selection" ]; then
        selection="$(printf '%s\n' "$selection_source" | head -n 1)"
      fi
    else
      fzf_set_common_opts "gworktree> " "$(fzf_join_header "Root: $root" "Enter to print path; --code to open")" "right,60%,border-left"
      preview_cmd='git -C {} status -sb || true'
      fzf_add_preview "$preview_cmd" "right,60%,border-left"

      selection="$(printf '%s\n' "$selection_source" | fzf "${FZF_COMMON_OPTS[@]}" --with-nth=1,2,3 --delimiter=$'\t')" || exit 0
    fi

    target_path="$(printf '%s' "$selection" | awk -F '\t' '{print $3}')"
    [ -n "$target_path" ] || exit 0

    if [ "$open_code" -eq 1 ]; then
      if command -v code >/dev/null 2>&1; then
        code "$target_path"
      else
        log_warn "VS Code not found; printing path."
        printf '%s\n' "$target_path"
      fi
    else
      printf '%s\n' "$target_path"
    fi
    ;;

  *)
    log_fatal "Unknown command: $cmd"
    ;;
esac
