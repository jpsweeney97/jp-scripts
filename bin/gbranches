#!/usr/bin/env bash
set -euo pipefail

# Name: gbranches
# Category: git
# Description: Show local branches with HEAD marker, upstream, ahead/behind, and last commit.
# Usage:
#   gbranches          # list all local branches
#   gbranches --merged <base>   # only branches merged into <base> (e.g. main)
#
# Notes:
# - Must be run inside a git repo.
# - ahead/behind is relative to the branch's upstream, if it has one.

usage() {
  sed -n '4,40p' "$0" | sed 's/^# \?//'
}

case "${1-}" in
  -h|--help)
    usage
    exit 0
    ;;
esac

SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]:-$0}")" && pwd)"
REPO_ROOT="$(cd -- "$SCRIPT_DIR/.." && pwd)"
# shellcheck source=../lib/git.sh disable=SC1091
. "$REPO_ROOT/lib/git.sh"

if ! git_require_repo; then
  exit 1
fi

MERGED_BASE=""

while [ "$#" -gt 0 ]; do
  case "$1" in
    --merged)
      if [ "${2-}" = "" ]; then
        printf 'Error: --merged requires a base branch.\n' >&2
        exit 1
      fi
      MERGED_BASE="$2"
      shift 2
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    -*)
      printf 'Error: unknown option: %s\n' "$1" >&2
      usage >&2
      exit 1
      ;;
    *)
      printf 'Error: unexpected argument: %s\n' "$1" >&2
      usage >&2
      exit 1
      ;;
  esac
done

CURRENT_BRANCH="$(git_current_branch)"

# Base list of branches
if [ -n "$MERGED_BASE" ]; then
  BRANCHES="$(git branch --format='%(refname:short)' --merged "$MERGED_BASE")"
else
  BRANCHES="$(git branch --format='%(refname:short)')"
fi

if [ -z "$BRANCHES" ]; then
  printf 'No branches found.\n'
  exit 0
fi

printf '%-2s %-25s %-25s %-9s %-12s %s\n' \
  'H' 'BRANCH' 'UPSTREAM' 'AHEAD/BEH' 'DATE' 'LAST COMMIT'
printf '%s\n' '--------------------------------------------------------------------------------------------------------'

# For each branch, compute details
while IFS= read -r br; do
  [ -z "$br" ] && continue

  HEAD_MARK=" "
  if [ "$br" = "$CURRENT_BRANCH" ]; then
    HEAD_MARK="*"
  fi

  upstream="$(git_upstream_ref "$br")"
  upstream_short="$upstream"
  if [ -n "$upstream_short" ]; then
    upstream_short="${upstream_short#refs/remotes/}"
  fi

  ahead_behind="--/--"
  if [ -n "$upstream" ]; then
    # rev-list: left=upstream (behind), right=branch (ahead)
    counts="$(git_ahead_behind "$upstream" "$br")"
    behind="$(printf '%s' "$counts" | awk '{print $1}')"
    ahead="$(printf '%s' "$counts" | awk '{print $2}')"
    ahead_behind="${ahead}/${behind}"
  fi

  # last commit date + subject
  info="$(git log -1 --format='%cs %s' -- "$br" 2>/dev/null || printf '---------- (no commits)')"
  last_date="$(printf '%s' "$info" | awk '{print $1}')"
  last_subject="$(printf '%s' "$info" | cut -d' ' -f2- )"

  printf '%-2s %-25s %-25s %-9s %-12s %s\n' \
    "$HEAD_MARK" "$br" "${upstream_short:-"-"}" "$ahead_behind" "$last_date" "$last_subject"
done <<EOF
$BRANCHES
EOF
