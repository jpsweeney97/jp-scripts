#!/usr/bin/env bash
set -euo pipefail

# Name: recent
# Category: nav
# Description: Fuzzy-jump to recently modified files (or dirs) under the current project root.
# Usage:
#   recent                 # pick a recent file, print its path
#   recent --edit          # pick and open in code/$EDITOR
#   recent --since 2d      # limit to items modified in the last 2 days
#   recent --dirs          # include directories in the list

usage() {
  sed -n '4,80p' "$0" | sed 's/^# \?//'
}

SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]:-$0}")" && pwd)"
REPO_ROOT="$(cd -- "$SCRIPT_DIR/.." && pwd)"
# shellcheck source=../lib/config.sh disable=SC1091
. "$REPO_ROOT/lib/config.sh"
# shellcheck source=../lib/log.sh disable=SC1091
. "$REPO_ROOT/lib/log.sh"
# shellcheck source=../lib/deps.sh disable=SC1091
. "$REPO_ROOT/lib/deps.sh"
# shellcheck source=../lib/fs.sh disable=SC1091
. "$REPO_ROOT/lib/fs.sh"
# shellcheck source=../lib/fzf.sh disable=SC1091
. "$REPO_ROOT/lib/fzf.sh"
# shellcheck source=../lib/git.sh disable=SC1091
. "$REPO_ROOT/lib/git.sh"

OPEN_EDITOR=false
INCLUDE_DIRS=0
MAX_ITEMS=200
SINCE_THRESHOLD=0
EXCLUDES=()
ONLY=()
NON_INTERACTIVE=0

fmt_epoch() {
  local epoch="$1"
  if date -r "$epoch" '+%Y-%m-%d %H:%M' >/dev/null 2>&1; then
    date -r "$epoch" '+%Y-%m-%d %H:%M'
  else
    date -d "@$epoch" '+%Y-%m-%d %H:%M'
  fi
}

fmt_size() {
  local size="$1"
  local units=(B KB MB GB TB)
  local i=0
  local val="$size"

  while [ "$val" -ge 1024 ] && [ "$i" -lt $((${#units[@]} - 1)) ]; do
    val=$((val / 1024))
    i=$((i + 1))
  done

  printf '%s%s' "$val" "${units[$i]}"
}

parse_since() {
  # Accepts forms like 2h, 3d, 30m, 1w. Returns epoch threshold.
  local spec="$1"
  if ! [[ "$spec" =~ ^([0-9]+)([smhdw])$ ]]; then
    log_fatal "Invalid --since value: $spec (use number + s/m/h/d/w)"
  fi

  local num="${BASH_REMATCH[1]}"
  local unit="${BASH_REMATCH[2]}"
  local seconds=0

  case "$unit" in
    s) seconds=$num ;;
    m) seconds=$((num * 60)) ;;
    h) seconds=$((num * 3600)) ;;
    d) seconds=$((num * 86400)) ;;
    w) seconds=$((num * 604800)) ;;
  esac

  SINCE_THRESHOLD=$(( $(date +%s) - seconds ))
}

open_in_editor() {
  local path="$1"
  if command -v code >/dev/null 2>&1; then
    code "$path"
  elif [ -n "${EDITOR:-}" ]; then
    $EDITOR "$path"
  else
    log_warn "No editor found; printing path only."
    printf '%s\n' "$path"
  fi
}

while [ "$#" -gt 0 ]; do
  case "$1" in
    --edit)
      OPEN_EDITOR=true
      shift
      ;;
    --dirs)
      INCLUDE_DIRS=1
      shift
      ;;
    --max)
      MAX_ITEMS="${2:-}"
      if ! [[ "$MAX_ITEMS" =~ ^[0-9]+$ ]]; then
        log_fatal "--max expects a number"
      fi
      shift 2
      ;;
    --since)
      [ -n "${2-}" ] || log_fatal "--since requires a value"
      parse_since "$2"
      shift 2
      ;;
    --first|--non-interactive)
      NON_INTERACTIVE=1
      shift
      ;;
    --exclude)
      [ -n "${2-}" ] || log_fatal "--exclude requires a glob"
      EXCLUDES+=("$2")
      shift 2
      ;;
    --only)
      [ -n "${2-}" ] || log_fatal "--only requires a glob"
      ONLY+=("$2")
      shift 2
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      log_fatal "Unknown option: $1"
      ;;
  esac
done

root="."
if git_is_repo; then
  root="$(git_repo_root)"
else
  root="$(pwd)"
fi

log_debug "root=$root include_dirs=$INCLUDE_DIRS max=$MAX_ITEMS since=$SINCE_THRESHOLD"

if [ "$NON_INTERACTIVE" -eq 1 ] || [ "${RECENT_NONINTERACTIVE:-0}" -eq 1 ]; then
  raw_list="$(fs_list_by_mtime "$root" "$INCLUDE_DIRS" "$MAX_ITEMS" "${EXCLUDES[@]}")"
  if [ -z "$raw_list" ]; then
    log_warn "No files found under $root"
    exit 1
  fi
  first_path="$(printf '%s\n' "$raw_list" | head -n 1 | cut -f3)"
  if [ "$OPEN_EDITOR" = true ]; then
    open_in_editor "$first_path"
  else
    printf '%s\n' "$first_path"
  fi
  exit 0
fi

deps_require fzf fzf || exit 1
deps_warn_missing fd fd "faster file listing" || true
deps_warn_missing bat bat "preview highlighting" || true

fzf_set_common_opts "recent> " "$(fzf_join_header "Root: $root" "Use --edit to open in editor")"
fzf_add_default_preview 200 "right,60%,border-left"

raw_list="$(fs_list_by_mtime "$root" "$INCLUDE_DIRS" 0 "${EXCLUDES[@]}")"
if [ -z "$raw_list" ]; then
  log_warn "No files found under $root"
  exit 0
fi

filtered="$(
  printf '%s\n' "$raw_list" \
    | while IFS=$'\t' read -r mtime size path; do
        [ -z "$mtime" ] && continue
        if [ "$SINCE_THRESHOLD" -gt 0 ] && [ "$mtime" -lt "$SINCE_THRESHOLD" ]; then
          continue
        fi

        ok_only=1
        if [ "${#ONLY[@]}" -gt 0 ]; then
          ok_only=0
          for pat in "${ONLY[@]}"; do
            case "$path" in
              *$pat*) ok_only=1 ;;
            esac
          done
        fi
        [ "$ok_only" -eq 0 ] && continue

        rel="${path#"$root"/}"
        printf '%s\t%s\t%s\t%s\n' "$mtime" "$size" "$rel" "$path"
      done \
    | sort -rn -k1,1
)"

if [ -z "$filtered" ]; then
  log_warn "No files matched filters."
  exit 0
fi

if [ "$MAX_ITEMS" -gt 0 ]; then
  filtered="$(printf '%s\n' "$filtered" | head -n "$MAX_ITEMS")"
fi

if [ "${RECENT_NONINTERACTIVE:-$NON_INTERACTIVE}" -eq 1 ]; then
  selection="$(printf '%s\n' "$filtered" | head -n 1 | cut -f4)"
  selected_path="$selection"
else
  selection="$(
    printf '%s\n' "$filtered" \
      | while IFS=$'\t' read -r mtime size rel path; do
          printf '%s\t%s\t%s\t%s\n' "$(fmt_epoch "$mtime")" "$(fmt_size "$size")" "$rel" "$path"
        done \
      | fzf "${FZF_COMMON_OPTS[@]}" --with-nth=1,2,3 --delimiter=$'\t' --bind 'enter:accept' --preview-window='right,60%,border-left'
  )" || exit 0

  selected_path="$(printf '%s' "$selection" | awk -F '\t' '{print $4}')"
fi

if [ -z "$selected_path" ]; then
  exit 0
fi

if [ "$OPEN_EDITOR" = true ]; then
  open_in_editor "$selected_path"
else
  printf '%s\n' "$selected_path"
fi
