#!/usr/bin/env bash
set -uo pipefail

# Name: jp-diagnose
# Category: meta
# Description: Comprehensive jp-scripts health dashboard (registry, syntax, deps, runtime).
# Usage:
#   jp-diagnose

usage() {
  sed -n '4,40p' "$0" | sed 's/^# \?//'
}

SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]:-$0}")" && pwd)"
REPO_ROOT="$(cd -- "$SCRIPT_DIR/.." && pwd)"

# shellcheck source=../lib/log.sh disable=SC1091
. "$REPO_ROOT/lib/log.sh"
# shellcheck source=../lib/git.sh disable=SC1091
. "$REPO_ROOT/lib/git.sh"

case "${1-}" in
  -h|--help)
    usage
    exit 0
    ;;
  "")
    ;;
  *)
    log_error "Unknown argument: $1"
    usage >&2
    exit 1
    ;;
esac

if ! cd "$REPO_ROOT"; then
  log_error "Failed to change directory to $REPO_ROOT"
  exit 1
fi

if ! git_require_repo || ! git_is_repo; then
  log_error "jp-diagnose must be run inside the jp-scripts repository."
  exit 1
fi

REPO_ROOT="$(git_repo_root)"
REGISTRY_PATH="$REPO_ROOT/registry/commands.json"

if ! cd "$REPO_ROOT"; then
  log_error "Failed to change directory to $REPO_ROOT"
  exit 1
fi

CHECK_MARK="✅"
CROSS_MARK="❌"

now_ms() {
  if command -v python3 >/dev/null 2>&1; then
    python3 - <<'PY'
import time
print(int(time.time() * 1000))
PY
  elif command -v python >/dev/null 2>&1; then
    python - <<'PY'
import time
print(int(time.time() * 1000))
PY
  else
    date +%s 2>/dev/null | awk '{printf "%d000\n", $1}'
  fi
}

repeat_char() {
  local char="$1"
  local count="$2"
  printf '%*s\n' "$count" '' | tr ' ' "$char"
}

registry_loaded=0
jq_available=0
overall_ok=1
issue_lines=()

if command -v jq >/dev/null 2>&1; then
  jq_available=1
else
  overall_ok=0
  issue_lines+=("jq not found on PATH; registry and dependency checks are incomplete.")
fi

if [ -f "$REGISTRY_PATH" ]; then
  registry_loaded=1
else
  overall_ok=0
  issue_lines+=("registry missing at $REGISTRY_PATH.")
fi

log_info "Repository root: $REPO_ROOT"
if git_is_dirty; then
  log_warn "Repository has uncommitted changes."
else
  log_info "Repository clean."
fi

if [ "$jq_available" -eq 1 ]; then
  log_info "jq is available."
else
  log_error "jq is required for registry and dependency checks."
fi

log_info "Scanning executables in bin/"

rows=()

for script_path in "$REPO_ROOT"/bin/*; do
  [ -f "$script_path" ] || continue
  [ -x "$script_path" ] || continue

  rel_path="bin/$(basename "$script_path")"
  log_info "Checking $rel_path..."

  registry_present=0
  requires=()

  if [ "$registry_loaded" -eq 1 ] && [ "$jq_available" -eq 1 ]; then
    registry_entry="$(jq -c --arg path "$rel_path" '
      .commands | map(select(.path == $path)) | if length > 0 then .[0] else empty end
    ' "$REGISTRY_PATH" 2>/dev/null | head -n 1 || true)"

    if [ -n "$registry_entry" ]; then
      registry_present=1
      while IFS= read -r req; do
        [ -z "$req" ] && continue
        requires+=("$req")
      done < <(printf '%s' "$registry_entry" | jq -r '.requires // [] | .[]')
    fi
  fi

  syntax_ok=1
  if ! bash -n "$script_path" >/dev/null 2>&1; then
    syntax_ok=0
    overall_ok=0
    issue_lines+=("$rel_path: bash -n failed")
  fi

  metadata_missing=()
  header_block="$(head -n 25 "$script_path" 2>/dev/null)"
  for field in Name Category Description; do
    if ! printf '%s\n' "$header_block" | grep -Eq "^# +$field:"; then
      metadata_missing+=("$field")
    fi
  done

  if [ "${#metadata_missing[@]}" -gt 0 ]; then
    syntax_ok=0
    overall_ok=0
    issue_lines+=("$rel_path: missing metadata fields: ${metadata_missing[*]}")
  fi

  deps_ok=1
  missing_deps=()
  if [ "$registry_present" -eq 1 ]; then
    for dep in "${requires[@]}"; do
      if ! command -v "$dep" >/dev/null 2>&1; then
        deps_ok=0
        missing_deps+=("$dep")
      fi
    done

    if [ "${#missing_deps[@]}" -gt 0 ]; then
      overall_ok=0
      issue_lines+=("$rel_path: missing dependencies: ${missing_deps[*]}")
    fi
  fi

  if [ "$registry_loaded" -eq 1 ] && [ "$jq_available" -eq 1 ] && [ "$registry_present" -ne 1 ]; then
    overall_ok=0
    issue_lines+=("$rel_path: not listed in registry/commands.json")
  fi

  start_ms=$(now_ms)
  "$script_path" --help >/dev/null 2>&1
  help_exit=$?
  end_ms=$(now_ms)
  time_ms=$((end_ms - start_ms))

  if [ "$help_exit" -ne 0 ]; then
    overall_ok=0
    issue_lines+=("$rel_path: --help exited with $help_exit")
  fi

  registry_display="$CROSS_MARK"
  [ "$registry_present" -eq 1 ] && registry_display="$CHECK_MARK"

  syntax_display="$CROSS_MARK"
  [ "$syntax_ok" -eq 1 ] && syntax_display="$CHECK_MARK"

  if [ "$registry_loaded" -ne 1 ] || [ "$jq_available" -ne 1 ]; then
    deps_display="registry unavailable"
  elif [ "$registry_present" -ne 1 ]; then
    deps_display="no registry entry"
  elif [ "${#requires[@]}" -eq 0 ]; then
    deps_display="(none)"
  elif [ "${#missing_deps[@]}" -eq 0 ]; then
    deps_display="all installed"
  else
    deps_display="missing: ${missing_deps[*]}"
  fi

  rows+=("$rel_path"$'\t'"$registry_display"$'\t'"$syntax_display"$'\t'"$deps_display"$'\t'"$help_exit"$'\t'"$time_ms")
done

script_header="SCRIPT"
registry_header="REGISTRY"
syntax_header="SYNTAX"
deps_header="DEPS"
exit_header="EXIT_CODE"
time_header="TIME(ms)"

script_w=${#script_header}
deps_w=${#deps_header}
exit_w=${#exit_header}
time_w=${#time_header}

for row in "${rows[@]}"; do
  IFS=$'\t' read -r script reg syn deps exit_code time_ms <<< "$row"

  [ "${#script}" -gt "$script_w" ] && script_w=${#script}
  [ "${#deps}" -gt "$deps_w" ] && deps_w=${#deps}
  [ "${#exit_code}" -gt "$exit_w" ] && exit_w=${#exit_code}
  [ "${#time_ms}" -gt "$time_w" ] && time_w=${#time_ms}
done

row_format="%-${script_w}s %-8s %-8s %-${deps_w}s %${exit_w}s %${time_w}s\n"

printf '\n'
printf "$row_format" "$script_header" "$registry_header" "$syntax_header" "$deps_header" "$exit_header" "$time_header"
total_width=$((script_w + 1 + 8 + 1 + 8 + 1 + deps_w + 1 + exit_w + 1 + time_w))
repeat_char "-" "$total_width"

for row in "${rows[@]}"; do
  IFS=$'\t' read -r script reg syn deps exit_code time_ms <<< "$row"
  printf "$row_format" "$script" "$reg" "$syn" "$deps" "$exit_code" "$time_ms"
done

if [ "${#issue_lines[@]}" -gt 0 ]; then
  printf '\n'
  log_info "Details:"
  for issue in "${issue_lines[@]}"; do
    printf '  - %s\n' "$issue"
  done
fi

if [ "${#rows[@]}" -eq 0 ]; then
  log_error "No executable scripts found in bin/."
  exit 1
fi

if [ "$overall_ok" -eq 1 ]; then
  exit 0
else
  exit 1
fi
