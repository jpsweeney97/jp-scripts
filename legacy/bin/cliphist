#!/usr/bin/env bash
set -euo pipefail

# Name: cliphist
# Category: notes
# Description: Simple clipboard history: save, browse, and restore clipboard entries.
# Usage:
#   cliphist save        # save current clipboard contents
#   cliphist             # browse history with fzf, restore selected to clipboard
#   cliphist clear       # delete all saved entries (with confirmation)
#
# Env:
#   CLIPHIST_DIR   Directory for history files (default: $HOME/.local/share/jp-cliphist)

usage() {
  sed -n '4,40p' "$0" | sed 's/^# \?//'
}

SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]:-$0}")" && pwd)"
REPO_ROOT="$(cd -- "$SCRIPT_DIR/.." && pwd)"
# shellcheck source=../lib/fzf.sh disable=SC1091
. "$REPO_ROOT/lib/fzf.sh"

case "${1-}" in
  -h|--help)
    usage
    exit 0
    ;;
esac

HIST_DIR="${CLIPHIST_DIR:-"$HOME/.local/share/jp-cliphist"}"
mkdir -p "$HIST_DIR"

if ! command -v pbpaste >/dev/null 2>&1 || ! command -v pbcopy >/dev/null 2>&1; then
  printf 'Error: cliphist requires pbpaste/pbcopy (macOS clipboard tools).\n' >&2
  exit 1
fi

cmd="${1-}"

save_clipboard() {
  local tmp file last

  tmp="$(mktemp "${TMPDIR:-/tmp}/cliphist.XXXXXX")"
  pbpaste >"$tmp"

  if [ ! -s "$tmp" ]; then
    printf 'Clipboard is empty; nothing to save.\n'
    rm -f "$tmp"
    return
  fi

  # Use timestamp-based filename; replace ":" so it's filesystem-safe.
  file="$(date -Iseconds | tr ':' '-' ).txt"
  file="$HIST_DIR/$file"

  # Optional: avoid saving if identical to most recent entry.
  # shellcheck disable=SC2012  # We just need the newest file; ls is sufficient here.
  last="$(ls -1t "$HIST_DIR" 2>/dev/null | head -n 1 || true)"
  if [ -n "$last" ] && cmp -s "$tmp" "$HIST_DIR/$last"; then
    printf 'Clipboard unchanged from last saved entry; not saving duplicate.\n'
    rm -f "$tmp"
    return
  fi

  mv "$tmp" "$file"
  printf 'Saved clipboard to %s\n' "$file"
}

browse_and_restore() {
  if ! fzf_require; then
    exit 1
  fi

  if ! command -v bat >/dev/null 2>&1; then
    printf 'Error: cliphist interactive mode requires bat.\n' >&2
    exit 1
  fi

  # List files newest first
  mapfile -t files < <(ls -1t "$HIST_DIR" 2>/dev/null || true)
  if [ "${#files[@]}" -eq 0 ]; then
    printf 'No clipboard history entries found. Use "cliphist save" first.\n'
    exit 0
  fi

  # Build menu: TIMESTAMP | first line
  menu=""
  for f in "${files[@]}"; do
    first_line="$(head -n 1 "$HIST_DIR/$f" | tr '\t' ' ' | cut -c1-80)"
    ts="${f%.txt}"
    menu+="$ts | $first_line"$'\n'
  done

  fzf_set_common_opts "cliphist> " "Select clipboard entry to restore (ENTER), ESC to cancel."

  selection="$(
    printf '%s' "$menu" \
      | fzf "${FZF_COMMON_OPTS[@]}" \
            --with-nth=1,2 \
            --preview "ts=\$(printf \"%s\" {} | cut -d\"|\" -f1 | sed \"s/ *$//\"); \
                       file=\$(printf \"%s.txt\" \"\$ts\"); \
                       bat --style=plain --color=always --line-range=1:200 \"$HIST_DIR/\$file\" 2>/dev/null"
  )" || exit 0

  ts_sel="$(printf '%s' "$selection" | cut -d'|' -f1 | sed 's/ *$//')"
  [ -z "$ts_sel" ] && { printf 'No selection.\n'; exit 0; }

  file="$HIST_DIR/$ts_sel.txt"

  if [ ! -f "$file" ]; then
    printf 'Selected file missing: %s\n' "$file" >&2
    exit 1
  fi

  pbcopy <"$file"
  printf 'Restored clipboard from %s\n' "$file"
}

clear_history() {
  mapfile -t files < <(ls -1 "$HIST_DIR" 2>/dev/null || true)
  if [ "${#files[@]}" -eq 0 ]; then
    printf 'No history files to delete.\n'
    return
  fi

  printf 'This will delete %d clipboard history entries in %s\n' "${#files[@]}" "$HIST_DIR"
  printf 'Proceed? [y/N]: '
  read -r reply
  case "$reply" in
    y|Y|yes|YES)
      rm -f "$HIST_DIR"/*
      printf 'Clipboard history cleared.\n'
      ;;
    *)
      printf 'Aborted.\n'
      ;;
  esac
}

case "$cmd" in
  save)
    save_clipboard
    ;;
  clear)
    clear_history
    ;;
  "" )
    browse_and_restore
    ;;
  * )
    usage >&2
    exit 1
    ;;
esac
