#!/usr/bin/env bash
set -euo pipefail

# Name: jpdoctor
# Category: meta
# Description: Check for presence/versions of key CLI tools and suggest Homebrew installs.
# Usage:
#   jpdoctor
#   jpdoctor tools           # check install status of tools referenced by commands.json requires
#   jpdoctor command <name>  # check requires for a single command in commands.json

# Each entry: command|brew_formula|category|note

usage() {
  sed -n '4,40p' "$0" | sed 's/^# \?//'
}

SCRIPT_DIR="$(cd -- "$(dirname -- "${BASH_SOURCE[0]:-$0}")" && pwd)"
REPO_ROOT="$(cd -- "$SCRIPT_DIR/.." && pwd)"
REGISTRY_PATH="$REPO_ROOT/registry/commands.json"

MODE="default"
COMMAND_NAME=""

if [ "$#" -gt 0 ]; then
  case "$1" in
    -h|--help)
      usage
      exit 0
      ;;
    tools)
      MODE="tools"
      shift
      ;;
    command)
      MODE="command"
      shift
      if [ "${1-}" = "" ]; then
        printf 'Error: jpdoctor command <name> requires a command name.\n' >&2
        usage >&2
        exit 1
      fi
      COMMAND_NAME="$1"
      shift
      ;;
    *)
      printf 'Error: unknown argument: %s\n' "$1" >&2
      usage >&2
      exit 1
      ;;
  esac
fi

if [ "$#" -gt 0 ]; then
  printf 'Error: unexpected argument(s): %s\n' "$*" >&2
  usage >&2
  exit 1
fi

TOOLS=(
  "fzf|fzf|search|Fuzzy finder (history, files)."
  "jq|jq|text|JSON processor."
  "yq|yq|text|YAML processor."
  "rg|ripgrep|search|Fast grep-like search."
  "fd|fd|search|Fast find-like search."
  "pandoc|pandoc|docs|Document converter."
  "bat|bat|text|Pager/cat with syntax highlighting."
  "sd|sd|text|Search & replace (regex-friendly)."
  "zoxide|zoxide|nav|Smart directory jumping (cd on rails)."
  "eza|eza|fs|Modern ls replacement."
  "ffmpeg|ffmpeg|media|Audio/video Swiss army knife."
  "convert|imagemagick|media|ImageMagick image converter."
  "yt-dlp|yt-dlp|media|YouTube/media downloader."
  "htop|htop|system|Interactive process viewer."
  "btop|btop|system|Fancy system monitor."
  "ncdu|ncdu|system|Disk usage explorer."
  "mas|mas|system|Mac App Store CLI."
  "blueutil|blueutil|macos|Bluetooth control."
  "SwitchAudioSource|switchaudio-osx|macos|Audio input/output switcher."
  "entr|entr|dev|Run commands when files change."
  "parallel|parallel|dev|GNU parallel for running jobs in parallel."
  "sponge|moreutils|dev|Soak stdin then write once (from moreutils)."
  "ts|moreutils|dev|Timestamp lines (from moreutils)."
  "gh|gh|dev|GitHub CLI."
  "pup|pup|web|HTML parser with CSS selectors."
  "stow|stow|config|Dotfile symlink manager."
  "gsed|gnu-sed|text|GNU sed (stronger than BSD sed)."
  "lazygit|lazygit|git|TUI for git."
  "lazydocker|lazydocker|docker|TUI for Docker."
  "direnv|direnv|env|Per-directory environment loader."
  "hyperfine|hyperfine|bench|Command-line benchmark tool."
)

get_version() {
  local cmd="$1"
  local out=""

  case "$cmd" in
    ffmpeg)
      out="$(ffmpeg -version 2>/dev/null | head -n 1 || true)"
      ;;
    convert)
      out="$(convert -version 2>/dev/null | head -n 1 || true)"
      ;;
    mas)
      out="$(mas version 2>/dev/null | head -n 1 || true)"
      ;;
    SwitchAudioSource)
      out="$(SwitchAudioSource -h 2>&1 | head -n 1 || true)"
      ;;
    sponge|ts)
      # These are stream filters from moreutils; they don't have a safe --version
      # flag and will block waiting for stdin, so we skip version detection.
      out=""
      ;;
    *)
      out="$("$cmd" --version 2>/dev/null | head -n 1 || true)"
      ;;
  esac

  printf '%s' "$out" | tr -d '\r'
}

ensure_registry() {
  if ! command -v jq >/dev/null 2>&1; then
    printf 'Error: jpdoctor metadata modes require jq. Install with: brew install jq\n' >&2
    exit 1
  fi

  if [ ! -f "$REGISTRY_PATH" ]; then
    printf 'Error: registry not found at %s\n' "$REGISTRY_PATH" >&2
    exit 1
  fi
}

doctor_tools_mode() {
  ensure_registry

  printf '%-14s %-9s %-10s %s\n' "TOOL" "STATUS" "VERSION" "REQUIRED_BY"
  printf '%s\n' "--------------------------------------------------------------------"

  jq -r '
    .commands
    | map({name, requires: (.requires // [])})
    | map(.requires[]? as $r | {tool: $r, cmd: .name})
    | group_by(.tool)
    | map({tool: .[0].tool, commands: (map(.cmd) | unique | sort)})[]
    | [.tool, (.commands | join(", "))]
    | @tsv
  ' "$REGISTRY_PATH" \
  | while IFS=$'\t' read -r tool required_by; do
      [ -z "$tool" ] && continue
      if command -v "$tool" >/dev/null 2>&1; then
        status="INSTALLED"
        version="$(get_version "$tool")"
        [ -z "$version" ] && version="-"
      else
        status="missing"
        version="-"
      fi

      printf '%-14s %-9s %-10s %s\n' "$tool" "$status" "$version" "$required_by"
    done
}

doctor_command_mode() {
  local cmd_name="$1"
  local cmd_json description
  local requires=()

  ensure_registry

  cmd_json="$(jq -c --arg n "$cmd_name" '
    .commands
    | map(select(.name == $n))
    | if length == 0 then {} else .[0] end
  ' "$REGISTRY_PATH")"

  if [ "$cmd_json" = "{}" ] || [ -z "$cmd_json" ]; then
    printf 'Error: no command named %s in registry.\n' "$cmd_name" >&2
    exit 1
  fi

  description="$(printf '%s' "$cmd_json" | jq -r '.description')"
  mapfile -t requires < <(printf '%s' "$cmd_json" | jq -r '.requires // [] | .[]')

  printf 'Command:     %s\n' "$cmd_name"
  printf 'Description: %s\n' "$description"

  if [ "${#requires[@]}" -eq 0 ]; then
    printf '\nRequires:    (none listed)\n'
    return
  fi

  printf '\n%-12s %-9s %-10s\n' "REQUIRE" "STATUS" "VERSION"
  printf '%s\n' '------------------------------------'

  for req in "${requires[@]}"; do
    if command -v "$req" >/dev/null 2>&1; then
      status="INSTALLED"
      version="$(get_version "$req")"
      [ -z "$version" ] && version="-"
    else
      status="missing"
      version="-"
    fi

    printf '%-12s %-9s %-10s\n' "$req" "$status" "$version"
  done
}

case "$MODE" in
  tools)
    doctor_tools_mode
    exit 0
    ;;
  command)
    doctor_command_mode "$COMMAND_NAME"
    exit 0
    ;;
esac


printf '%-16s %-9s %-10s %-16s %-10s %s\n' \
  "COMMAND" "STATUS" "VERSION" "FORMULA" "CATEGORY" "NOTE"
printf '%s\n' "--------------------------------------------------------------------------------------------"

missing_formulae=""
installed_count=0
missing_count=0

for entry in "${TOOLS[@]}"; do
  IFS='|' read -r cmd formula category note <<< "$entry"

  if command -v "$cmd" >/dev/null 2>&1; then
    status="INSTALLED"
    installed_count=$((installed_count + 1))
    version="$(get_version "$cmd")"
    [ -z "$version" ] && version="-"
  else
    status="missing"
    missing_count=$((missing_count + 1))
    version="-"

    # Build a space-separated list of unique missing formulas
    case " $missing_formulae " in
      *" $formula "*) : ;;  # already present
      *)
        missing_formulae="$missing_formulae $formula"
        ;;
    esac
  fi

  printf '%-16s %-9s %-10s %-16s %-10s %s\n' \
    "$cmd" "$status" "$version" "$formula" "$category" "$note"
done

printf '\nSummary: %d installed, %d missing (from this list).\n' "$installed_count" "$missing_count"

if command -v brew >/dev/null 2>&1 && [ -n "$missing_formulae" ]; then
  printf '\nTo install missing tools via Homebrew (safe to copy/paste):\n\n'
  printf '  brew install%s\n' "$missing_formulae"
elif [ -n "$missing_formulae" ]; then
  printf '\nHomebrew not found on PATH; cannot suggest brew install line.\n'
fi
